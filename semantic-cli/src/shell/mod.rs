// shell/mod.rs
// Handles shell detection and alias/function generation.
// `semantic init` outputs shell-specific code that the user evals in their rc file.
//
// Usage:
//   Fish:  semantic init | source
//   Bash:  eval "$(semantic init)"
//   Zsh:   eval "$(semantic init)"

use std::collections::HashMap;
use std::env;

/// Detect the current shell from $SHELL env var.
/// Returns just the shell name (e.g. "fish", "bash", "zsh").
pub fn detect_shell() -> String {
    env::var("SHELL")
        .ok()
        .and_then(|s| s.rsplit('/').next().map(String::from))
        .unwrap_or_else(|| "bash".to_string())
}

/// Generate shell init code that creates aliases/functions for all semantic commands.
/// Also handles path translation for commands that take path arguments.
///
/// For most commands, we generate simple aliases.
/// For commands that map to "cd" we generate shell functions instead,
/// since cd is a shell builtin that can't work through a subprocess.
pub fn generate_init(
    commands: &HashMap<String, String>,
    paths: &HashMap<String, String>,
    shell: &str,
) -> String {
    let mut output = String::new();

    // header comment
    output.push_str(&format!(
        "# SemanticOS shell init ({shell})\n# Auto-generated by `semantic init`\n\n"
    ));

    // find the semantic binary path so aliases can call it
    let semantic_bin = env::current_exe()
        .map(|p| p.display().to_string())
        .unwrap_or_else(|_| "semantic".to_string());

    for (alias, real_cmd) in commands {
        // skip identity mappings (traditional style)
        if alias == real_cmd {
            continue;
        }

        // cd needs to be a shell function, not an alias,
        // because cd only works in the current shell process
        if real_cmd == "cd" || real_cmd.starts_with("cd ") {
            output.push_str(&generate_cd_function(alias, real_cmd, paths, shell));
        } else {
            output.push_str(&generate_alias(alias, real_cmd, &semantic_bin, shell));
        }
    }

    output
}

/// Generate a shell function for cd-like commands.
/// These need path translation (e.g. /apps -> /usr/bin) built in.
fn generate_cd_function(
    alias: &str,
    real_cmd: &str,
    paths: &HashMap<String, String>,
    shell: &str,
) -> String {
    match shell {
        "fish" => generate_cd_function_fish(alias, real_cmd, paths),
        _ => generate_cd_function_posix(alias, real_cmd, paths, shell),
    }
}

/// Fish shell cd function with path translation.
fn generate_cd_function_fish(
    alias: &str,
    real_cmd: &str,
    paths: &HashMap<String, String>,
) -> String {
    // if the real command already has args (like "cd .."), make it a simple function
    if real_cmd.contains(' ') {
        return format!(
            "function {alias}\n    {real_cmd}\nend\n\n"
        );
    }

    // otherwise, build a function that translates paths before cd'ing
    let mut func = format!("function {alias}\n    set -l target $argv[1]\n");

    // add path translation cases
    for (virtual_path, real_path) in paths {
        func.push_str(&format!(
            "    if test \"$target\" = \"{virtual_path}\"\n        set target \"{real_path}\"\n    end\n"
        ));
    }

    func.push_str("    cd $target\nend\n\n");
    func
}

/// Bash/Zsh cd function with path translation.
fn generate_cd_function_posix(
    alias: &str,
    real_cmd: &str,
    paths: &HashMap<String, String>,
    _shell: &str,
) -> String {
    // if the real command already has args (like "cd .."), make it a simple function
    if real_cmd.contains(' ') {
        return format!(
            "{alias}() {{\n    {real_cmd}\n}}\n\n"
        );
    }

    // build a function with path translation via case statement
    let mut func = format!("{alias}() {{\n    local target=\"$1\"\n    case \"$target\" in\n");

    for (virtual_path, real_path) in paths {
        func.push_str(&format!(
            "        \"{virtual_path}\") target=\"{real_path}\" ;;\n"
        ));
    }

    func.push_str("    esac\n    cd \"$target\"\n}\n\n");
    func
}

/// Generate an alias that delegates to `semantic translate`.
/// The semantic binary handles looking up the command and running it.
fn generate_alias(alias: &str, _real_cmd: &str, semantic_bin: &str, shell: &str) -> String {
    match shell {
        "fish" => format!(
            "function {alias}\n    {semantic_bin} translate {alias} $argv\nend\n\n"
        ),
        _ => format!(
            "{alias}() {{\n    \"{semantic_bin}\" translate {alias} \"$@\"\n}}\n\n"
        ),
    }
}
